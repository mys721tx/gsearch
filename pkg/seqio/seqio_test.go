/*
 *  GSEARCH: A concurrent tool suite for metagenomics
 *  Copyright (C) 2018  Yishen Miao
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 */
package seqio_test

import (
	"bytes"
	"io"
	"os"
	"sync"
	"testing"

	"github.com/biogo/biogo/alphabet"
	"github.com/biogo/biogo/io/seqio/fasta"
	"github.com/biogo/biogo/seq/linear"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	"github.com/mys721tx/gsearch/pkg/seqio"
)

// MockReader is an autogenerated mock type for the Reader type
type MockReader struct {
	mock.Mock
}

// Read provides a mock function with given fields: p
func (_m *MockReader) Read(p []byte) (int, error) {
	ret := _m.Called(p)

	var r0 int
	if rf, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = rf(p)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// writeString writes the sequence to string via a writer
func writeString(s *linear.Seq) string {
	f := bytes.NewBufferString("")

	w := fasta.NewWriter(f, seqio.WidthCol)

	w.Write(s)

	return f.String()
}

func TestReadSeq(t *testing.T) {

	seq := linear.NewSeq("Foo", []alphabet.Letter("AAAA"), alphabet.DNA)

	f := bytes.NewBufferString(writeString(seq))

	s, err := seqio.ReadSeq(f)

	if assert.NoError(t, err) {
		assert.Equal(t, s.Annotation.ID, seq.Annotation.ID,
			"Annotation.ID should be the same as input",
		)
		assert.Equal(t, s.Annotation.Desc, seq.Annotation.Desc,
			"Annotation.Desc should be the same as input.",
		)
		assert.Equal(t, s.Annotation.Loc, seq.Annotation.Loc,
			"Annotation.Loc should be the same as input",
		)
		assert.Equal(t, s.Annotation.Strand, seq.Annotation.Strand,
			"Annotation.Strand should be the same as input.",
		)
		assert.Equal(t, s.Annotation.Conform, seq.Annotation.Conform,
			"Annotation.Conform should be the same as input.",
		)
		assert.Equal(t, s.Annotation.Offset, seq.Annotation.Offset,
			"Annotation.Offset should be the same as input.",
		)
		assert.Equal(t, s.Seq, seq.Seq,
			"Seq should be the FASTA sequence.",
		)
	}
}

func TestReadSeqReaderError(t *testing.T) {

	f := new(MockReader)

	f.On("Read", mock.Anything).Return(0, os.ErrPermission)

	s, err := seqio.ReadSeq(f)

	if assert.Error(t, err) {
		assert.Nil(t, s,
			"nil should be returned when an error occurs.",
		)
	}

	f.On("Read", mock.Anything).Return(0, os.ErrNotExist)

	s, err = seqio.ReadSeq(f)

	if assert.Error(t, err) {
		assert.Nil(t, s,
			"nil should be returned when an error occurs.",
		)
	}

	f.On("Read", mock.Anything).Return(0, os.ErrNotExist)

	s, err = seqio.ReadSeq(f)

	if assert.Error(t, err) {
		assert.Nil(t, s,
			"nil should be returned when an error occurs.",
		)
	}

	f.On("Read", mock.Anything).Return(0, io.EOF)

	s, err = seqio.ReadSeq(f)

	if assert.Error(t, err) {
		assert.Nil(t, s,
			"nil should be returned when an error occurs.",
		)
	}
}

func TestReadSeqMalform(t *testing.T) {

	f := bytes.NewBufferString("AAAA\n")

	s, err := seqio.ReadSeq(f)

	if assert.Error(t, err) {
		assert.Nil(t, s,
			"nil should be returned when an error occurs.",
		)
	}
}

func TestScanSeq(t *testing.T) {

	var wg sync.WaitGroup

	seqs := []*linear.Seq{
		linear.NewSeq("Foo", []alphabet.Letter("AAAA"), alphabet.DNA),
		linear.NewSeq("Bar", []alphabet.Letter("GGGG"), alphabet.DNA),
	}

	var fExp string

	for _, s := range seqs {
		fExp += writeString(s)
	}

	out := make(chan *linear.Seq)

	f := bytes.NewBufferString(fExp)

	wg.Add(1)

	go seqio.ScanSeq(f, out, &wg)

	for _, seq := range seqs {
		s := <-out
		assert.Equal(t, s.Annotation.ID, seq.Annotation.ID,
			"Annotation.ID should be the same as input",
		)
		assert.Equal(t, s.Annotation.Desc, seq.Annotation.Desc,
			"Annotation.Desc should be the same as input.",
		)
		assert.Equal(t, s.Annotation.Loc, seq.Annotation.Loc,
			"Annotation.Loc should be the same as input",
		)
		assert.Equal(t, s.Annotation.Strand, seq.Annotation.Strand,
			"Annotation.Strand should be the same as input.",
		)
		assert.Equal(t, s.Annotation.Conform, seq.Annotation.Conform,
			"Annotation.Conform should be the same as input.",
		)
		assert.Equal(t, s.Annotation.Offset, seq.Annotation.Offset,
			"Annotation.Offset should be the same as input.",
		)
		assert.Equal(t, s.Seq, seq.Seq,
			"Seq should be the FASTA sequence.",
		)
	}

	wg.Wait()
}

func TestWriteSeq(t *testing.T) {

	var wg sync.WaitGroup

	seqs := []*linear.Seq{
		linear.NewSeq("Foo", []alphabet.Letter("AAAA"), alphabet.DNA),
		linear.NewSeq("Bar", []alphabet.Letter("GGGG"), alphabet.DNA),
	}

	in := make(chan *linear.Seq)

	wg.Add(1)

	f := bytes.NewBufferString("")

	go seqio.WriteSeq(f, in, &wg)

	var fExp string

	for _, s := range seqs {
		in <- s
		fExp += writeString(s)
	}

	close(in)

	wg.Wait()

	assert.Equal(t, f.String(), fExp,
		"Output should be the same as input sequence.",
	)
}
